<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Defense Command</title>
    <style>
        /* =================================
           CSS VARIABLES & MODERN DESIGN SYSTEM
        ================================= */
        :root {
            --bg-primary: #000814;
            --bg-secondary: #001427;
            --accent-neon: #00e5a8;
            --accent-warning: #ff6b35;
            --accent-danger: #ff4d6d;
            --text-primary: #e6f7f3;
            --text-muted: #9aa6b2;
            --glass: rgba(255, 255, 255, 0.03);
            --glass-border: rgba(255, 255, 255, 0.08);
            --neon-glow: 0 0 20px var(--accent-neon);
            --shadow-depth: 0 8px 40px rgba(0, 0, 0, 0.6);
        }

        /* =================================
           GLOBAL STYLES & LAYOUT
        ================================= */
        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 0;
            background: radial-gradient(ellipse at center, #001021 0%, var(--bg-primary) 60%);
            color: var(--text-primary);
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        #gameContainer {
            position: relative;
            width: min(1000px, 95vw);
            height: min(700px, 85vh);
            background: linear-gradient(180deg, var(--bg-secondary), rgba(0, 0, 0, 0.6));
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            box-shadow: var(--shadow-depth), inset 0 1px 0 rgba(255, 255, 255, 0.02);
            overflow: hidden;
            backdrop-filter: blur(10px);
        }

        #gameCanvas {
            display: block;
            background: transparent;
            width: 100%;
            height: 100%;
        }

        /* =================================
           UI OVERLAY STYLES
        ================================= */
        #ui {
            position: absolute;
            top: 12px;
            left: 12px;
            z-index: 10;
            display: flex;
            gap: 16px;
            align-items: center;
            background: var(--glass);
            padding: 10px 16px;
            border-radius: 10px;
            border: 1px solid var(--glass-border);
            backdrop-filter: blur(10px);
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            font-size: 14px;
            color: var(--text-muted);
        }

        #ui .stat {
            margin: 0;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        #ui .stat span {
            color: var(--accent-neon);
            font-weight: 600;
        }

        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(4px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            text-align: center;
        }

        #startScreen h1 {
            font-size: clamp(28px, 5vw, 48px);
            color: var(--accent-neon);
            margin-bottom: 8px;
            text-shadow: var(--neon-glow);
            letter-spacing: 3px;
            font-weight: 700;
            text-transform: uppercase;
        }

        #startScreen .subtitle {
            color: var(--text-muted);
            margin-bottom: 30px;
            font-size: 16px;
            max-width: 500px;
            line-height: 1.6;
        }

        #startScreen button {
            font-size: 18px;
            padding: 14px 32px;
            background: linear-gradient(135deg, var(--accent-neon), #00b386);
            color: var(--bg-primary);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #startScreen button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 229, 168, 0.3);
        }

        #instructions {
            margin-top: 30px;
            text-align: left;
            max-width: 450px;
            background: var(--glass);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid var(--glass-border);
        }

        #instructions h3 {
            color: var(--accent-neon);
            margin-top: 0;
            margin-bottom: 16px;
            font-size: 18px;
        }

        #instructions p {
            margin: 8px 0;
            color: var(--text-muted);
            font-size: 14px;
            line-height: 1.5;
        }

        #gameOver {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(4px);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            text-align: center;
        }

        #gameOver h1 {
            color: var(--accent-danger);
            font-size: 36px;
            margin-bottom: 20px;
            text-shadow: 0 0 20px var(--accent-danger);
        }

        #gameOver p {
            color: var(--text-muted);
            font-size: 18px;
            margin: 10px 0;
        }

        #gameOver button {
            font-size: 16px;
            padding: 12px 28px;
            background: var(--accent-danger);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            margin-top: 20px;
            transition: all 0.3s ease;
            font-weight: 600;
        }

        #gameOver button:hover {
            background: #e43d5a;
            transform: translateY(-2px);
        }

        .wave-complete {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 32px;
            color: var(--accent-neon);
            z-index: 50;
            display: none;
            text-shadow: var(--neon-glow);
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 2px;
            animation: pulse 2s ease-in-out;
        }

        #costIndicator {
            position: absolute;
            bottom: 12px;
            right: 12px;
            z-index: 10;
            background: var(--glass);
            padding: 10px 16px;
            border-radius: 10px;
            border: 1px solid var(--glass-border);
            backdrop-filter: blur(10px);
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            font-size: 14px;
            color: var(--text-muted);
        }

        .cost-info {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .cost-icon {
            font-size: 16px;
        }

        .cost-text {
            color: var(--text-primary);
        }

        .cost-text strong {
            color: var(--accent-neon);
            font-weight: 600;
        }

        #costIndicator.insufficient {
            border-color: var(--accent-danger);
        }

        #costIndicator.insufficient .cost-text {
            color: var(--accent-danger);
        }

        #upgradePanel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 15;
            background: var(--glass);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid var(--glass-border);
            backdrop-filter: blur(15px);
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            min-width: 300px;
            box-shadow: var(--shadow-depth);
        }

        .upgrade-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 16px;
            color: var(--accent-warning);
            font-weight: 600;
            font-size: 16px;
        }

        .upgrade-icon {
            font-size: 20px;
        }

        .upgrade-stats {
            margin-bottom: 20px;
            color: var(--text-muted);
            font-size: 14px;
        }

        .upgrade-stats div {
            margin: 8px 0;
            display: flex;
            justify-content: space-between;
        }

        .upgrade-stats span {
            color: var(--accent-neon);
            font-weight: 600;
        }

        .upgrade-actions {
            display: flex;
            gap: 12px;
        }

        .upgrade-actions button {
            flex: 1;
            padding: 10px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
            font-weight: 600;
        }

        #upgradeBtn {
            background: var(--accent-warning);
            color: var(--bg-primary);
        }

        #upgradeBtn:hover:not(:disabled) {
            background: #e55a2b;
            transform: translateY(-1px);
        }

        #upgradeBtn:disabled {
            background: #555;
            color: #999;
            cursor: not-allowed;
        }

        .upgrade-actions button:last-child {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: var(--text-muted);
        }

        .upgrade-actions button:last-child:hover {
            background: rgba(255, 255, 255, 0.2);
            color: var(--text-primary);
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 0.7; transform: translate(-50%, -50%) scale(1.05); }
        }

        /* =================================
           RESPONSIVE DESIGN
        ================================= */
        @media (max-width: 768px) {
            #gameContainer {
                border-radius: 0;
                width: 100vw;
                height: 100vh;
            }

            #ui {
                font-size: 12px;
                gap: 12px;
                padding: 8px 12px;
            }

            #startScreen h1 {
                font-size: 32px;
            }

            #instructions {
                max-width: 90%;
                padding: 16px;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <!-- Game Canvas -->
        <canvas id="gameCanvas" width="1000" height="700"></canvas>
        
        <!-- UI Overlay -->
        <div id="ui">
            <div class="stat">Wave: <span id="wave">1</span></div>
            <div class="stat">Score: <span id="score">0</span></div>
            <div class="stat">Resources: <span id="resources">100</span></div>
            <div class="stat">Base Health: <span id="baseHealth">100</span></div>
            <div class="stat">Enemies Left: <span id="enemiesLeft">0</span></div>
        </div>

        <!-- Start Screen -->
        <div id="startScreen">
            <h1>Space Defense Command</h1>
            <p class="subtitle">Strategic tower defense in the depths of space. Place turrets, defend your base, survive the alien invasion.</p>
            <button onclick="startGame()">LAUNCH DEFENSE</button>
            <div id="instructions">
                <h3>Mission Briefing</h3>
                <p>üéØ Click empty spots to place turrets (Cost: 50 resources)</p>
                <p>‚ö° Click existing turrets to upgrade them (3 levels max)</p>
                <p>üöÄ Turrets automatically target and fire homing projectiles</p>
                <p>üõ°Ô∏è Protect your base from alien invasion!</p>
                <p>‚≠ê Each wave gets harder - plan and upgrade your defense!</p>
            </div>
        </div>

        <!-- Game Over Screen -->
        <div id="gameOver">
            <h1>DEFENSE BREACHED</h1>
            <p>Your base has fallen to the alien invasion</p>
            <p>Final Score: <span id="finalScore">0</span></p>
            <p>Waves Survived: <span id="wavesSurvived">0</span></p>
            <button onclick="restartGame()">REDEPLOY DEFENSES</button>
        </div>

        <!-- Wave Complete Message -->
        <div class="wave-complete" id="waveComplete">WAVE COMPLETE!</div>

        <!-- Cost Indicator -->
        <div id="costIndicator">
            <div class="cost-info">
                <span class="cost-icon">üéØ</span>
                <span class="cost-text">Turret Cost: <strong>50</strong> resources</span>
            </div>
        </div>

        <!-- Upgrade Panel -->
        <div id="upgradePanel" style="display: none;">
            <div class="upgrade-header">
                <span class="upgrade-icon">‚ö°</span>
                <span>Upgrade Turret</span>
            </div>
            <div id="upgradeInfo" class="upgrade-stats">
                <div>Level: <span id="turretLevel">1/3</span></div>
                <div>Damage: <span id="turretDamage">25</span></div>
                <div>Range: <span id="turretRange">150</span></div>
                <div>Fire Rate: <span id="turretFireRate">1.3/sec</span></div>
            </div>
            <div class="upgrade-actions">
                <button id="upgradeBtn" onclick="upgradeSelectedTurret()">Upgrade (60)</button>
                <button onclick="hideUpgradePanel()">Close</button>
            </div>
        </div>
    </div>

    <script>
        /* =================================
           GAME STATE AND CONFIGURATION
        ================================= */
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Game state
        let gameState = {
            isPlaying: false,
            score: 0,
            resources: 100,
            wave: 1,
            baseHealth: 100,
            gameOver: false
        };

        // Game objects arrays
        let turrets = [];
        let enemies = [];
        let projectiles = [];
        let particles = [];
        
        // Upgrade system
        let selectedTurret = null;

        // Enemy path (curved path from left to right)
        const enemyPath = [
            {x: -50, y: 350},
            {x: 100, y: 350},
            {x: 200, y: 200},
            {x: 400, y: 150},
            {x: 600, y: 300},
            {x: 800, y: 400},
            {x: 1000, y: 350},
            {x: 1100, y: 350}
        ];

        // Wave management
        let currentWave = [];
        let waveComplete = false;
        let enemiesSpawned = 0;
        let nextSpawnTime = 0;

        /* =================================
           GAME CLASSES
        ================================= */

        class Turret {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.level = 1;
                this.maxLevel = 3;
                
                // Base stats
                this.baseRange = 150;
                this.baseDamage = 25;
                this.baseFireRate = 800;
                
                // Update stats based on level
                this.updateStats();
                
                this.lastShot = 0;
                this.target = null;
                this.angle = 0;
            }

            updateStats() {
                // Scale stats with level
                this.range = this.baseRange + (this.level - 1) * 25;
                this.damage = this.baseDamage + (this.level - 1) * 15;
                this.fireRate = Math.max(300, this.baseFireRate - (this.level - 1) * 150);
            }

            getUpgradeCost() {
                if (this.level >= this.maxLevel) return 0;
                return 40 + (this.level * 20); // Level 2: 60, Level 3: 80
            }

            canUpgrade() {
                return this.level < this.maxLevel && gameState.resources >= this.getUpgradeCost();
            }

            upgrade() {
                if (this.level < this.maxLevel && gameState.resources >= this.getUpgradeCost()) {
                    gameState.resources -= this.getUpgradeCost();
                    this.level++;
                    this.updateStats();
                    return true;
                }
                return false;
            }

            isClicked(mouseX, mouseY) {
                let distance = Math.sqrt((mouseX - this.x) ** 2 + (mouseY - this.y) ** 2);
                return distance <= 25;
            }

            update(timestamp) {
                // Find nearest enemy in range
                this.target = null;
                let closestDistance = this.range;
                
                for (let enemy of enemies) {
                    let distance = Math.sqrt(
                        Math.pow(enemy.x - this.x, 2) + 
                        Math.pow(enemy.y - this.y, 2)
                    );
                    
                    if (distance < closestDistance) {
                        this.target = enemy;
                        closestDistance = distance;
                    }
                }

                // Aim at target
                if (this.target) {
                    this.angle = Math.atan2(
                        this.target.y - this.y,
                        this.target.x - this.x
                    );

                    // Shoot if ready
                    if (timestamp - this.lastShot > this.fireRate) {
                        this.shoot(timestamp);
                        this.lastShot = timestamp;
                    }
                }
            }

            shoot(timestamp) {
                if (!this.target) return;
                
                projectiles.push(new Projectile(
                    this.x, this.y, 
                    this.target,
                    this.damage,
                    this.level
                ));
            }

            draw() {
                // Show range when selected
                if (this === selectedTurret) {
                    ctx.strokeStyle = 'rgba(0, 229, 168, 0.3)';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.range, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }

                // Draw turret base with level-based size
                const baseSize = 22 + (this.level - 1) * 4;
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, baseSize);
                
                // Level-based colors
                if (this.level >= 3) {
                    gradient.addColorStop(0, '#66ddff');
                    gradient.addColorStop(0.6, '#0099cc');
                    gradient.addColorStop(1, '#006699');
                } else if (this.level >= 2) {
                    gradient.addColorStop(0, '#ff8800');
                    gradient.addColorStop(0.6, '#cc6600');
                    gradient.addColorStop(1, '#994400');
                } else {
                    gradient.addColorStop(0, '#00e5a8');
                    gradient.addColorStop(0.6, '#00b386');
                    gradient.addColorStop(1, '#008866');
                }
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, baseSize, 0, Math.PI * 2);
                ctx.fill();

                // Add inner glow
                ctx.fillStyle = this.level >= 3 ? 'rgba(102, 221, 255, 0.4)' : 
                               this.level >= 2 ? 'rgba(255, 136, 0, 0.4)' : 
                               'rgba(0, 229, 168, 0.4)';
                ctx.beginPath();
                ctx.arc(this.x, this.y, baseSize - 4, 0, Math.PI * 2);
                ctx.fill();

                // Draw upgrade level indicators
                if (this.level > 1) {
                    for (let i = 0; i < this.level - 1; i++) {
                        const angle = (i * Math.PI * 2) / (this.level - 1);
                        const indicatorX = this.x + Math.cos(angle) * (baseSize - 6);
                        const indicatorY = this.y + Math.sin(angle) * (baseSize - 6);
                        
                        ctx.fillStyle = '#ffffff';
                        ctx.beginPath();
                        ctx.arc(indicatorX, indicatorY, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                // Draw turret core
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(this.x, this.y, 8, 0, Math.PI * 2);
                ctx.fill();

                // Draw turret barrel with level-based length
                const barrelLength = 30 + (this.level - 1) * 8;
                const barrelColor = this.level >= 3 ? '#66ddff' : 
                                  this.level >= 2 ? '#ff8800' : '#00e5a8';
                
                ctx.strokeStyle = barrelColor;
                ctx.lineWidth = 8;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(
                    this.x + Math.cos(this.angle) * barrelLength,
                    this.y + Math.sin(this.angle) * barrelLength
                );
                ctx.stroke();

                // Add barrel highlight
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 3;
                ctx.stroke();
            }
        }

        class Enemy {
            constructor(health, speed, reward) {
                this.health = health;
                this.maxHealth = health;
                this.speed = speed;
                this.reward = reward;
                this.pathIndex = 0;
                this.x = enemyPath[0].x;
                this.y = enemyPath[0].y;
                this.progress = 0;
            }

            update() {
                // Move along path
                if (this.pathIndex < enemyPath.length - 1) {
                    let current = enemyPath[this.pathIndex];
                    let next = enemyPath[this.pathIndex + 1];
                    
                    let dx = next.x - current.x;
                    let dy = next.y - current.y;
                    let distance = Math.sqrt(dx * dx + dy * dy);
                    
                    this.progress += this.speed / distance;
                    
                    if (this.progress >= 1) {
                        this.pathIndex++;
                        this.progress = 0;
                    }
                    
                    if (this.pathIndex < enemyPath.length - 1) {
                        current = enemyPath[this.pathIndex];
                        next = enemyPath[this.pathIndex + 1];
                        
                        this.x = current.x + (next.x - current.x) * this.progress;
                        this.y = current.y + (next.y - current.y) * this.progress;
                    }
                }
            }

            takeDamage(damage) {
                this.health -= damage;
                return this.health <= 0;
            }

            reachedEnd() {
                return this.pathIndex >= enemyPath.length - 1;
            }

            draw() {
                // Draw enemy body with health-based coloring
                let healthPercent = this.health / this.maxHealth;
                let bodyColor = healthPercent > 0.5 ? '#ff6b35' : '#ff4d6d';
                
                // Enemy body gradient
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, 18);
                gradient.addColorStop(0, bodyColor);
                gradient.addColorStop(0.7, '#cc4420');
                gradient.addColorStop(1, '#aa3318');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 16, 0, Math.PI * 2);
                ctx.fill();

                // Add enemy glow
                ctx.fillStyle = `rgba(255, 107, 53, ${0.3 + healthPercent * 0.4})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 20, 0, Math.PI * 2);
                ctx.fill();

                // Draw enemy core
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(this.x, this.y, 6, 0, Math.PI * 2);
                ctx.fill();

                // Draw sleek health bar
                let barWidth = 32;
                let barHeight = 4;
                
                // Health bar background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                ctx.fillRect(this.x - barWidth/2, this.y - 28, barWidth, barHeight);
                
                // Health bar fill with gradient
                const healthGradient = ctx.createLinearGradient(
                    this.x - barWidth/2, this.y - 28,
                    this.x - barWidth/2 + barWidth * healthPercent, this.y - 28
                );
                healthGradient.addColorStop(0, healthPercent > 0.6 ? '#00e5a8' : '#ff6b35');
                healthGradient.addColorStop(1, healthPercent > 0.6 ? '#00b386' : '#ff4d6d');
                
                ctx.fillStyle = healthGradient;
                ctx.fillRect(
                    this.x - barWidth/2, 
                    this.y - 28, 
                    barWidth * healthPercent, 
                    barHeight
                );
                
                // Health bar border
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 1;
                ctx.strokeRect(this.x - barWidth/2, this.y - 28, barWidth, barHeight);
            }
        }

        class Projectile {
            constructor(x, y, target, damage, level = 1) {
                this.x = x;
                this.y = y;
                this.target = target;
                this.damage = damage;
                this.level = level;
                this.speed = 8 + (level - 1) * 2;
                this.homing = 0.15; // How aggressively it tracks
            }

            update() {
                if (!this.target || !enemies.includes(this.target)) {
                    return false; // Remove projectile if target is gone
                }

                // Calculate homing trajectory
                let dx = this.target.x - this.x;
                let dy = this.target.y - this.y;
                let distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 10) {
                    // Hit the target
                    if (this.target.takeDamage(this.damage)) {
                        // Enemy destroyed
                        gameState.score += this.target.reward;
                        gameState.resources += this.target.reward;
                        
                        // Create explosion particles (more for higher level)
                        const particleCount = 6 + this.level * 2;
                        for (let i = 0; i < particleCount; i++) {
                            particles.push(new Particle(
                                this.target.x, this.target.y,
                                Math.random() * Math.PI * 2,
                                2 + Math.random() * (2 + this.level),
                                this.level
                            ));
                        }
                        
                        // Remove enemy
                        let index = enemies.indexOf(this.target);
                        if (index > -1) enemies.splice(index, 1);
                    }
                    return false; // Remove projectile
                }

                // Homing movement
                dx /= distance;
                dy /= distance;
                
                this.x += dx * this.speed;
                this.y += dy * this.speed;
                
                return true; // Keep projectile
            }

            draw() {
                // Enhanced projectile based on level
                const size = 6 + this.level * 2;
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, size);
                
                if (this.level >= 3) {
                    // Level 3: Blue energy
                    gradient.addColorStop(0, '#ffffff');
                    gradient.addColorStop(0.3, '#66ddff');
                    gradient.addColorStop(1, 'rgba(102, 221, 255, 0)');
                } else if (this.level >= 2) {
                    // Level 2: Orange energy
                    gradient.addColorStop(0, '#ffffff');
                    gradient.addColorStop(0.3, '#ff8800');
                    gradient.addColorStop(1, 'rgba(255, 136, 0, 0)');
                } else {
                    // Level 1: Yellow energy
                    gradient.addColorStop(0, '#ffffff');
                    gradient.addColorStop(0.3, '#ffff00');
                    gradient.addColorStop(1, 'rgba(255, 255, 0, 0)');
                }
                
                // Outer glow
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, size, 0, Math.PI * 2);
                ctx.fill();
                
                // Core projectile
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(this.x, this.y, Math.max(2, size/2), 0, Math.PI * 2);
                ctx.fill();
            }
        }

        class Particle {
            constructor(x, y, angle, speed, level = 1) {
                this.x = x;
                this.y = y;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.life = 20 + level * 8;
                this.maxLife = this.life;
                this.level = level;
                this.size = 1 + level;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vx *= 0.98;
                this.vy *= 0.98;
                this.life--;
                return this.life > 0;
            }

            draw() {
                let alpha = this.life / this.maxLife;
                let currentSize = this.size * (1 + (1 - alpha) * 2); // Particles grow as they fade
                
                // Create gradient particle with level-based colors
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, currentSize);
                
                if (this.level >= 3) {
                    // Level 3: Blue explosion
                    gradient.addColorStop(0, `rgba(255, 255, 255, ${alpha})`);
                    gradient.addColorStop(0.5, `rgba(102, 221, 255, ${alpha * 0.8})`);
                    gradient.addColorStop(1, `rgba(0, 150, 255, ${alpha * 0.3})`);
                } else if (this.level >= 2) {
                    // Level 2: Orange explosion
                    gradient.addColorStop(0, `rgba(255, 255, 255, ${alpha})`);
                    gradient.addColorStop(0.5, `rgba(255, 136, 0, ${alpha * 0.8})`);
                    gradient.addColorStop(1, `rgba(255, 68, 0, ${alpha * 0.3})`);
                } else {
                    // Level 1: Yellow explosion
                    gradient.addColorStop(0, `rgba(255, 255, 255, ${alpha})`);
                    gradient.addColorStop(0.5, `rgba(255, 255, 0, ${alpha * 0.8})`);
                    gradient.addColorStop(1, `rgba(255, 107, 53, ${alpha * 0.3})`);
                }
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, currentSize, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        /* =================================
           GAME MECHANICS
        ================================= */

        function generateWave(waveNumber) {
            let wave = [];
            let enemyCount = 5 + waveNumber * 2;
            
            for (let i = 0; i < enemyCount; i++) {
                let enemyType = Math.random();
                let enemy;
                
                if (enemyType < 0.6) {
                    // Basic enemy
                    enemy = new Enemy(30 + waveNumber * 10, 1, 10);
                } else if (enemyType < 0.9) {
                    // Fast enemy
                    enemy = new Enemy(20 + waveNumber * 5, 2, 15);
                } else {
                    // Tank enemy
                    enemy = new Enemy(80 + waveNumber * 20, 0.5, 25);
                }
                
                wave.push(enemy);
            }
            
            return wave;
        }

        function spawnWave() {
            currentWave = generateWave(gameState.wave);
            enemiesSpawned = 0;
            nextSpawnTime = performance.now();
            waveComplete = false;
        }

        function checkWaveComplete() {
            if (!waveComplete && currentWave.length === 0 && enemies.length === 0) {
                waveComplete = true;
                gameState.wave++;
                gameState.resources += 50; // Wave completion bonus
                
                // Show wave complete message
                document.getElementById('waveComplete').style.display = 'block';
                setTimeout(() => {
                    document.getElementById('waveComplete').style.display = 'none';
                    spawnWave(); // Start next wave
                }, 2000);
            }
        }

        function handleClick(event) {
            if (!gameState.isPlaying || gameState.gameOver) return;
            
            let rect = canvas.getBoundingClientRect();
            let x = (event.clientX - rect.left) * (canvas.width / rect.width);
            let y = (event.clientY - rect.top) * (canvas.height / rect.height);
            
            // First check if clicking on an existing turret to upgrade
            for (let turret of turrets) {
                if (turret.isClicked(x, y)) {
                    selectTurret(turret);
                    return;
                }
            }
            
            // If not clicking on turret, try to place new one
            if (gameState.resources >= 50) {
                // Check if too close to existing turrets
                let canPlace = true;
                
                for (let turret of turrets) {
                    let distance = Math.sqrt((x - turret.x) ** 2 + (y - turret.y) ** 2);
                    if (distance < 45) {
                        canPlace = false;
                        break;
                    }
                }
                
                // Check if too close to path (more lenient)
                if (canPlace) {
                    for (let point of enemyPath) {
                        let distance = Math.sqrt((x - point.x) ** 2 + (y - point.y) ** 2);
                        if (distance < 45) {
                            canPlace = false;
                            break;
                        }
                    }
                }
                
                // Check boundaries (more lenient)
                if (canPlace && x > 30 && x < canvas.width - 30 && y > 30 && y < canvas.height - 30) {
                    turrets.push(new Turret(x, y));
                    gameState.resources -= 50;
                    hideUpgradePanel(); // Close any open upgrade panel
                } else {
                    showMessage("Invalid placement location!");
                }
            } else {
                showMessage("Need 50 resources to place turret!");
            }
        }

        function selectTurret(turret) {
            selectedTurret = turret;
            showUpgradePanel();
        }

        function showUpgradePanel() {
            if (!selectedTurret) return;
            
            const panel = document.getElementById('upgradePanel');
            const upgradeBtn = document.getElementById('upgradeBtn');
            
            // Update stats display
            document.getElementById('turretLevel').textContent = `${selectedTurret.level}/${selectedTurret.maxLevel}`;
            document.getElementById('turretDamage').textContent = selectedTurret.damage;
            document.getElementById('turretRange').textContent = selectedTurret.range;
            document.getElementById('turretFireRate').textContent = `${(1000 / selectedTurret.fireRate).toFixed(1)}/sec`;
            
            // Update upgrade button
            const cost = selectedTurret.getUpgradeCost();
            const canUpgrade = selectedTurret.canUpgrade();
            
            upgradeBtn.disabled = !canUpgrade;
            upgradeBtn.textContent = canUpgrade ? `Upgrade (${cost})` : 'Max Level';
            
            panel.style.display = 'block';
        }

        function hideUpgradePanel() {
            document.getElementById('upgradePanel').style.display = 'none';
            selectedTurret = null;
        }

        function upgradeSelectedTurret() {
            if (selectedTurret && selectedTurret.upgrade()) {
                showUpgradePanel(); // Refresh the panel
                showMessage(`Turret upgraded to level ${selectedTurret.level}!`, true);
            }
        }

        function showMessage(text, isPositive = false) {
            // Create temporary message element
            const message = document.createElement('div');
            message.textContent = text;
            
            const messageColor = isPositive ? 'var(--accent-neon)' : 'var(--accent-danger)';
            
            message.style.cssText = `
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0, 0, 0, 0.8);
                color: ${messageColor};
                padding: 12px 20px;
                border-radius: 8px;
                font-weight: 600;
                z-index: 60;
                animation: messagePopup 2s ease-out forwards;
            `;
            
            // Add keyframe animation
            if (!document.querySelector('#messageStyle')) {
                const style = document.createElement('style');
                style.id = 'messageStyle';
                style.textContent = `
                    @keyframes messagePopup {
                        0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
                        20% { opacity: 1; transform: translate(-50%, -50%) scale(1.05); }
                        80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                        100% { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
                    }
                `;
                document.head.appendChild(style);
            }
            
            document.getElementById('gameContainer').appendChild(message);
            
            // Remove message after animation
            setTimeout(() => {
                if (message.parentNode) {
                    message.parentNode.removeChild(message);
                }
            }, 2000);
        }

        /* =================================
           GAME LOOP AND RENDERING
        ================================= */

        function gameLoop(timestamp) {
            if (!gameState.isPlaying || gameState.gameOver) {
                requestAnimationFrame(gameLoop);
                return;
            }

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw starfield background
            drawBackground();
            
            // Draw enemy path
            drawPath();
            
            // Spawn enemies from current wave
            if (currentWave.length > 0 && timestamp >= nextSpawnTime) {
                enemies.push(currentWave.shift());
                nextSpawnTime = timestamp + 1000; // 1 second between spawns
            }

            // Update turrets
            for (let turret of turrets) {
                turret.update(timestamp);
                turret.draw();
            }

            // Update enemies
            for (let i = enemies.length - 1; i >= 0; i--) {
                let enemy = enemies[i];
                enemy.update();
                enemy.draw();
                
                if (enemy.reachedEnd()) {
                    gameState.baseHealth -= 20;
                    enemies.splice(i, 1);
                    
                    if (gameState.baseHealth <= 0) {
                        endGame();
                    }
                }
            }

            // Update projectiles
            for (let i = projectiles.length - 1; i >= 0; i--) {
                if (!projectiles[i].update()) {
                    projectiles.splice(i, 1);
                } else {
                    projectiles[i].draw();
                }
            }

            // Update particles
            for (let i = particles.length - 1; i >= 0; i--) {
                if (!particles[i].update()) {
                    particles.splice(i, 1);
                } else {
                    particles[i].draw();
                }
            }

            // Check wave completion
            checkWaveComplete();
            
            // Update UI
            updateUI();

            requestAnimationFrame(gameLoop);
        }

        function drawBackground() {
            // Create dynamic starfield
            ctx.fillStyle = '#ffffff';
            const time = performance.now() * 0.0001;
            
            for (let i = 0; i < 150; i++) {
                let x = (i * 137.5 + time * 10) % canvas.width;
                let y = (i * 177.3) % canvas.height;
                let twinkle = Math.sin(time * 3 + i) * 0.5 + 0.5;
                let alpha = 0.3 + twinkle * 0.7;
                
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.fillRect(x, y, 1, 1);
                
                // Add some larger stars
                if (i % 7 === 0) {
                    ctx.fillStyle = `rgba(0, 229, 168, ${alpha * 0.8})`;
                    ctx.fillRect(x - 1, y - 1, 2, 2);
                }
            }
        }

        function drawPath() {
            // Draw enemy path with neon effect
            ctx.strokeStyle = 'rgba(255, 107, 53, 0.2)';
            ctx.lineWidth = 50;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.beginPath();
            ctx.moveTo(enemyPath[0].x, enemyPath[0].y);
            
            for (let i = 1; i < enemyPath.length; i++) {
                ctx.lineTo(enemyPath[i].x, enemyPath[i].y);
            }
            ctx.stroke();
            
            // Add glowing outline
            ctx.strokeStyle = 'rgba(255, 107, 53, 0.6)';
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // Add center line
            ctx.strokeStyle = 'rgba(255, 107, 53, 0.8)';
            ctx.lineWidth = 1;
            ctx.stroke();
        }

        function updateUI() {
            document.getElementById('wave').textContent = gameState.wave;
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('resources').textContent = gameState.resources;
            document.getElementById('baseHealth').textContent = gameState.baseHealth;
            document.getElementById('enemiesLeft').textContent = enemies.length + currentWave.length;
            
            // Update cost indicator
            updateCostIndicator();
        }

        function updateCostIndicator() {
            const costIndicator = document.getElementById('costIndicator');
            const canAfford = gameState.resources >= 50;
            
            if (canAfford) {
                costIndicator.classList.remove('insufficient');
            } else {
                costIndicator.classList.add('insufficient');
            }
        }

        /* =================================
           GAME FLOW CONTROLS
        ================================= */

        function startGame() {
            document.getElementById('startScreen').style.display = 'none';
            gameState.isPlaying = true;
            gameState.gameOver = false;
            spawnWave();
            requestAnimationFrame(gameLoop);
        }

        function endGame() {
            gameState.gameOver = true;
            document.getElementById('finalScore').textContent = gameState.score;
            document.getElementById('wavesSurvived').textContent = gameState.wave - 1;
            document.getElementById('gameOver').style.display = 'flex';
        }

        function restartGame() {
            // Reset game state
            gameState = {
                isPlaying: false,
                score: 0,
                resources: 100,
                wave: 1,
                baseHealth: 100,
                gameOver: false
            };
            
            // Clear game objects and upgrade state
            turrets = [];
            enemies = [];
            projectiles = [];
            particles = [];
            currentWave = [];
            selectedTurret = null;
            
            // Hide all panels
            document.getElementById('upgradePanel').style.display = 'none';
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('startScreen').style.display = 'flex';
        }

        // Event listeners
        canvas.addEventListener('click', handleClick);

        // Initialize the game
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
